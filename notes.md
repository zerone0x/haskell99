# Haskell 99 Problems Notes

## P01-P10 问题总结

### 基本语法要点

1. 类型签名

   - `::` 表示"具有这样的类型"
   - `->` 表示函数映射
   - `=>` 表示类型约束
   - 例如：`myLast :: [a] -> a`

2. 类型约束

   - `Eq a =>` 表示类型 a 必须支持相等比较
   - 用于需要比较元素是否相等的函数
   - 例如：`compress :: Eq a => [a] -> [a]`

3. 模式匹配

   - `[]` 匹配空列表
   - `[x]` 匹配单元素列表
   - `(x:xs)` 匹配非空列表，x 是第一个元素，xs 是剩余元素
   - `_` 表示不关心的值

4. 列表操作
   - `:` 构造操作符，将元素添加到列表开头
   - `++` 列表连接操作符
   - `takeWhile` 保留满足条件的前缀
   - `dropWhile` 删除满足条件的前缀

### 问题解法要点

1. P01 (myLast)

   - 递归处理列表
   - 基本情况：空列表和单元素列表
   - 递归情况：处理剩余元素

2. P02 (myButLast)

   - 类似 P01，但找倒数第二个元素
   - 需要处理空列表和单元素列表的情况

3. P03 (elementAt)

   - 使用递归查找第 k 个元素
   - 需要处理边界情况（k 超出范围）

4. P04 (myLength)

   - 递归计算列表长度
   - 基本情况：空列表返回 0
   - 递归情况：1 + 剩余列表长度

5. P05 (myReverse)

   - 递归反转列表
   - 使用 `++` 连接列表
   - 基本情况：空列表和单元素列表

6. P06 (isPalindrome)

   - 比较列表和其反转是否相等
   - 需要 `Eq` 类型约束

7. P07 (flatten)

   - 处理嵌套列表
   - 需要定义特殊的数据类型表示嵌套结构

8. P08 (compress)

   - 去除连续重复元素
   - 使用 `Eq` 类型约束
   - 递归比较相邻元素

9. P09 (pack)

   - 将连续相同元素分组
   - 使用 `takeWhile` 和 `dropWhile`
   - 递归处理不同元素

10. P10 (encode)
    - 类似 P09，但记录每个组的长度
    - 需要处理空列表和单元素列表

### 重要概念

1. 递归

   - 总是需要基本情况（base case）
   - 递归情况需要向基本情况靠近
   - 递归是函数式编程的核心

2. 类型系统

   - 类型签名帮助捕获错误
   - 类型约束确保类型安全
   - 多态类型使函数更通用

3. 模式匹配

   - 使代码更清晰
   - 处理不同的输入情况
   - 避免复杂的条件判断

4. 高阶函数
   - 函数作为参数
   - 函数作为返回值
   - 抽象通用模式
